(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
	typeof define === 'function' && define.amd ? define(['exports'], factory) :
	(factory((global.LightRPC = {})));
}(this, (function (exports) { 'use strict';

var setTimeout = void 0;
if (typeof window !== 'undefined' && window.setTimeout) {
  var _window$1 = window;
  setTimeout = _window$1.setTimeout;
} else {
  // eslint-disable-line global-require
  var _require = require('timers');

  setTimeout = _require.setTimeout;
}

/**
 * Adds timeout to promise.
 * @param {number} timeout Timeout in miliseconds.
 * @param {Promise} promise Promise to wrap in timeout
 * @returns {Promise} A promise that will fail if it doesn't resolve or reject in specified timeout
 */
function createTimeout(timeout, promise) {
  return new Promise(function (resolve, reject) {
    setTimeout(function () {
      reject(new Error('Request has timed out. It should take no longer than ' + timeout + 'ms.'));
    }, timeout);
    promise.then(resolve, reject);
  });
}

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var JSONRPCError = function (_Error) {
  _inherits(JSONRPCError, _Error);

  function JSONRPCError(message, error) {
    _classCallCheck(this, JSONRPCError);

    var _this = _possibleConstructorReturn(this, (JSONRPCError.__proto__ || Object.getPrototypeOf(JSONRPCError)).call(this, message));

    _this.name = 'JSONRPCError';
    _this.error = error;
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(_this, _this.constructor);
    } else {
      _this.stack = new Error(message).stack;
    }
    return _this;
  }

  return JSONRPCError;
}(Error);

var JSONRPCNoResult = function (_Error2) {
  _inherits(JSONRPCNoResult, _Error2);

  function JSONRPCNoResult(message) {
    _classCallCheck(this, JSONRPCNoResult);

    var _this2 = _possibleConstructorReturn(this, (JSONRPCNoResult.__proto__ || Object.getPrototypeOf(JSONRPCNoResult)).call(this, message));

    _this2.name = 'JSONRPCNoResult';
    if (typeof Error.captureStackTrace === 'function') {
      Error.captureStackTrace(_this2, _this2.constructor);
    } else {
      _this2.stack = new Error(message).stack;
    }
    return _this2;
  }

  return JSONRPCNoResult;
}(Error);

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var fetch = void 0;
if (typeof window !== 'undefined' && window.fetch) {
  var _window = window;
  fetch = _window.fetch;
} else {
  fetch = require('cross-fetch'); // eslint-disable-line global-require
}

/**
 * Creates new JSON-RPC client.
 *
 * @param {String} address Address of the JSON RPC (HTTP) server.
 * @returns {Client} JSON-RPC client that you can use for sending and receiving data.
 */
function createClient(address) {
  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

  if (typeof address !== 'string') throw new Error('InvalidArgument: address has to ba a string');
  if ((typeof options === 'undefined' ? 'undefined' : _typeof(options)) !== 'object') throw new Error('InvalidArgument: options has to be an object');

  var clientOptions = _extends({
    timeout: 5000
  }, options);

  var nextRequestId = 0;

  var fetchURL = function fetchURL(request) {
    return fetch(address, {
      body: JSON.stringify(request),
      method: 'post',
      mode: 'cors'
    });
  };

  /**
   * Sends command to node
   * @param {String} method Method to execute
   * @param {any} params Method params
   * @param {Function} callback A callback that is called when response has been received
   * or request failed.
   */
  var send = function send(method, params, callback) {
    if (typeof method !== 'string') throw new Error('InvalidArgument: method has to be a string');
    if (!(params instanceof Array)) throw new Error('InvalidArgument: params has to be an array');
    if (typeof callback !== 'function') {
      throw new Error('InvalidArgument: callback has to be a function');
    }

    var request = {
      id: nextRequestId,
      jsonrpc: '2.0',
      method: method,
      params: params
    };
    nextRequestId += 1;

    createTimeout(clientOptions.timeout, fetchURL(request)).then(function (res) {
      return res.json();
    }).then(function (res) {
      if (res.error) {
        throw new JSONRPCError('Response contains error. See error property for details.', res.err);
      }
      if (!res.result) {
        throw new JSONRPCNoResult("Response doesn't contain result");
      }
      return res;
    }).then(function (res) {
      callback(null, res.result);
      return res;
    }).catch(function (err) {
      return callback(err, null);
    });
  };

  return { send: send };
}

exports.createClient = createClient;

Object.defineProperty(exports, '__esModule', { value: true });

})));
